/* Generated by wayland-scanner 1.18.0 */

#ifndef HWBUF_CLIENT_PROTOCOL_H
#define HWBUF_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_hwbuf The hwbuf protocol
 * Create wl_buffer objects from Android HardwareBuffers
 *
 * @section page_desc_hwbuf Description
 *
 * The Android graphics stack doesn't use the same mechanism as regular Linux for sharing graphics buffers. HardwareBuffer objects are used instead. This extension allows clients to use HardwareBuffers as backing buffers for wl_buffer objects, enabling native GLES and vulkan usage for clients on Android.
 *
 * @section page_ifaces_hwbuf Interfaces
 * - @subpage page_iface_hwbuf_manager - Create wl_buffer objects from Android HardwareBuffers
 * @section page_copyright_hwbuf Copyright
 * <pre>
 *
 * TODO choose license, probably MIT
 * </pre>
 */
struct hwbuf_manager;

/**
 * @page page_iface_hwbuf_manager hwbuf_manager
 * @section page_iface_hwbuf_manager_desc Description
 *
 * This global object allows clients create wl_buffers associated with a HardwareBuffer.
 * To initialize call set_socket and wait for the socket_received event.
 * After that create_buffer can be called.
 *
 * To destroy the wl_buffer objects, the client has to unmap the buffer memory (if mapped), release bindings to GLES and Vulkan and then destroy the HardwareBuffer, in addition to destroying the wl_buffer object.
 * @section page_iface_hwbuf_manager_api API
 * See @ref iface_hwbuf_manager.
 */
/**
 * @defgroup iface_hwbuf_manager The hwbuf_manager interface
 *
 * This global object allows clients create wl_buffers associated with a HardwareBuffer.
 * To initialize call set_socket and wait for the socket_received event.
 * After that create_buffer can be called.
 *
 * To destroy the wl_buffer objects, the client has to unmap the buffer memory (if mapped), release bindings to GLES and Vulkan and then destroy the HardwareBuffer, in addition to destroying the wl_buffer object.
 */
extern const struct wl_interface hwbuf_manager_interface;

/**
 * @ingroup iface_hwbuf_manager
 * @struct hwbuf_manager_listener
 */
struct hwbuf_manager_listener {
	/**
	 * Set a unix socket as the HardwareBuffer transfer channel
	 *
	 * The compositor has received and processed the set_socket
	 * request and is now ready to create buffers.
	 */
	void (*socket_received)(void *data,
				struct hwbuf_manager *hwbuf_manager);
};

/**
 * @ingroup iface_hwbuf_manager
 */
static inline int
hwbuf_manager_add_listener(struct hwbuf_manager *hwbuf_manager,
			   const struct hwbuf_manager_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) hwbuf_manager,
				     (void (**)(void)) listener, data);
}

#define HWBUF_MANAGER_DESTROY 0
#define HWBUF_MANAGER_SET_SOCKET 1
#define HWBUF_MANAGER_CREATE_BUFFER 2

/**
 * @ingroup iface_hwbuf_manager
 */
#define HWBUF_MANAGER_SOCKET_RECEIVED_SINCE_VERSION 1

/**
 * @ingroup iface_hwbuf_manager
 */
#define HWBUF_MANAGER_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_hwbuf_manager
 */
#define HWBUF_MANAGER_SET_SOCKET_SINCE_VERSION 1
/**
 * @ingroup iface_hwbuf_manager
 */
#define HWBUF_MANAGER_CREATE_BUFFER_SINCE_VERSION 1

/** @ingroup iface_hwbuf_manager */
static inline void
hwbuf_manager_set_user_data(struct hwbuf_manager *hwbuf_manager, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) hwbuf_manager, user_data);
}

/** @ingroup iface_hwbuf_manager */
static inline void *
hwbuf_manager_get_user_data(struct hwbuf_manager *hwbuf_manager)
{
	return wl_proxy_get_user_data((struct wl_proxy *) hwbuf_manager);
}

static inline uint32_t
hwbuf_manager_get_version(struct hwbuf_manager *hwbuf_manager)
{
	return wl_proxy_get_version((struct wl_proxy *) hwbuf_manager);
}

/**
 * @ingroup iface_hwbuf_manager
 *
 * The interface is no longer accessible by the client after this.
 * All wl_buffer objects stay valid.
 */
static inline void
hwbuf_manager_destroy(struct hwbuf_manager *hwbuf_manager)
{
	wl_proxy_marshal((struct wl_proxy *) hwbuf_manager,
			 HWBUF_MANAGER_DESTROY);

	wl_proxy_destroy((struct wl_proxy *) hwbuf_manager);
}

/**
 * @ingroup iface_hwbuf_manager
 *
 * The wire format for HardwareBuffers isn't stable, so they can't be transferred in this protocol. The Android NDK has stable functions for transferring them over unix sockets though, so this will be used to transfer them. If another socket was already set for this client, the compositor closes the connection and uses the new one instead. The socket_received event is fired when the socket is received and ready for use.
 */
static inline void
hwbuf_manager_set_socket(struct hwbuf_manager *hwbuf_manager, int32_t fd)
{
	wl_proxy_marshal((struct wl_proxy *) hwbuf_manager,
			 HWBUF_MANAGER_SET_SOCKET, fd);
}

/**
 * @ingroup iface_hwbuf_manager
 *
 * The compositor will create a HardwareBuffer and corresponding wl_buffer. The hardware buffer is send over the previously set socket. The format used will be XRGB8888.
 */
static inline void *
hwbuf_manager_create_buffer(struct hwbuf_manager *hwbuf_manager, uint32_t width, uint32_t height, const struct wl_interface *interface, uint32_t version)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_constructor_versioned((struct wl_proxy *) hwbuf_manager,
			 HWBUF_MANAGER_CREATE_BUFFER, interface, version, width, height, interface->name, version, NULL);

	return (void *) id;
}

#ifdef  __cplusplus
}
#endif

#endif
